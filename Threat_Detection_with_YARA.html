<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Threat Detection with YARA</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>Threat Detection with YARA</h1><br/><br /><br /><h3>Skills we will:</h3><br />• Identify fundamental file Indicators of Compromise (IoCs)<br />• Develop YARA rules from scratch<br />• Generate YARA rules efficiently using yarGen<br />• Validate and test YARA rules effectively using Arya<br /><br /><br />In this Project we will learn how to identify potential threats by collecting Indicators of Compromise (IoCs) from simulated malicious files. Create YARA rules, generate detection rules using yarGen, and validate them with Arya. This experience provides essential skills in threat detection.<br /><br /><h3>For this Project we will need:</h3><br /><br /><h3>Repo for YARA: https://github.com/VirusTotal/yara</h3><br /><br />We can Just type “yara” in the command line, if you don’t have it, it should prompt you to download it. Select ‘Y’ for yes on both questions it prompts you with.<br />Or use git clone https://github.com/VirusTotal/yara<br /><br /><h3>Repo for yarGen: github.com/Neo23x0/yarGen</h3><br /><br />Run the following commands from your shell:<br />mkdir ~/tools &amp;&amp; cd ~/tools<br />git clone https://github.com/Neo23x0/yarGen.git<br /><br /><h3>Repo for Arya: github.com/claroty/arya</h3><br /><br />For this one, make sure you&#39;re in your ~/tools directory still.<br />git clone https://github.com/claroty/arya.git<br /><br /><h3>Repo for labscript: https://github.com/Jayteaare/labscript.git</h3><br /><br /> clone https://github.com/Jayteaare/labscript.git<br />**This will create a folder called labscript, with a file inside by the name of lab.sh.<br /><br /><h3>One last thing:</h3><br />I will be utilizing a Virtual Machine deployed in VMware and opting for the Linux distribution AntiX due to its low RAM consumption.<br /><br /><br /><h2>IoC Colletion </h2><br /><br />To begin, navigate to the directory where you saved the file, then type the following command <br /><br /><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">bash</span> lab.sh</pre></div><br />Navigate to your Desktop and you shall see a new file. For this lab, we’ll put ourselfs in a position where an end user noticed a suspicious document on their desktop and our job is to run analysis on this to make indicators of compromise (IoCs).<br /><br /><a href=""><img src="images/44-1.png" alt="images/44-1.png" /></a><br /><br /><br /><br />First, right click the file and go to properties. The initial things we can get for IoCs are the name of the file, the extension, file path, and size in bytes.<br /><br /><a href=""><img src="images/44-2.png" alt="images/44-2.png" /></a><br /><br /><h3>So far here is our IoC list:</h3><br />• File name and type: kenobi.txt<br />• File path: /home/Sitka/Desktop<br />• Size: 24 bytes<br />• Modify Time: 10:18:19 10 Aug 2023<br /><br />Now, let&#39;s utilize the &#39;strings&#39; tool on the file. The &#39;strings&#39; tool is designed to extract sequences of characters that form &#39;human-readable&#39; strings. Often, running this tool results in a large amount of nonsensical characters. To cultivate good practice, we&#39;ll redirect the text output generated by this tool into a new .txt file.<br /><br />In reality, since this is a text file, you could simply use the &#39;cat&#39; command to display its contents or open it in a text editor. However, when dealing with actual malicious files, especially executables, it&#39;s crucial to employ the &#39;strings&#39; tool.<br /><br /><h3>Run the following command:</h3><br /><div class="codebox"><pre>strings kenobi.txt &gt; kenobistrings.txt</pre></div><br /><br /><br />Afterward, run the &#39;cat&#39; command on the newly created &#39;strings .txt&#39; file. This will allow us to observe the text that the file contained:<br />“Hello there! star{warz}”<br /><br /><br /><a href=""><img src="images/44-3.png" alt="images/44-3.png" /></a><br /><br /><br /><h3>Current list of IoC:</h3><br />• File name and type: kenobi.txt<br />• File path: /home/Sitka/Desktop<br />• Size: 24 bytes<br />• Modify Time: 10:18:19 10 Aug 2023<br />• Strings: “Hello there! star{warz}”<br /><br /><br /><h3>Now, let&#39;s obtain the MD5, SHA-1 and SHA-256 hash for the file using the following commands:</h3><br /><div class="codebox"><pre>md5sum kenobi.txt</pre></div><br /><div class="codebox"><pre>sha1sum kenobi.txt</pre></div><br /><div class="codebox"><pre>sha256sum kenobi.txt</pre></div><br /><br /><a href=""><img src="images/44-4.png" alt="images/44-4.png" /></a><br /><br />As a standard practice, I ensure to acquire the MD5, SHA-1, and SHA-256 hashes of any file I&#39;m working with. This approach serves as a proactive defense against collision attacks. A collision attack is a type of cryptographic attack where two distinct inputs yield the same hash value (known as a hash collision) when processed through a hash function. Hash functions are designed to convert variable-length input data into fixed-length hash values. In cryptographic applications, these hash values should ideally be unique for different inputs. However, due to the finite hash output space and the inherent characteristics of hash functions, there exists a theoretical possibility for disparate inputs to generate the same hash value.Therefore this practice helps mitigate the risks associated with collision attacks and reinforces the security of data integrity.<br /><br /><h3>Current List of IoC:</h3><br />• File name and type: kenobi.txt<br />• File path: /home/Sitka/Desktop<br />• Size: 24 bytes<br />• Modify Time: 10:18:19 10 Aug 2023<br />• Strings: “Hello there! star{warz}”<br />• MD5 Hash: f1bc52b1c4da8b1d9dbe44bf41697d9d<br />• SHA-1 Hash: acf20e2e687005925149527e979220d21ded5696<br />• SHA-256 Hash: a6592f3b045c0bd897899a25b3b0b10a4c8444e28764cfcf2717dee1b67d3ecb<br /><br /><h2>Yara Rule Creation:</h2><br /><br />To craft an Yara rule, we first have to create a file witg tge YARA extension<br /><br /><div class="codebox"><pre>nano kenobiIoC.yara</pre></div><br /><br />Executing this command will initiate the nano text editor, enabling us to compose the YARA rule.<br /><br /><a href=""><img src="images/44-5.png" alt="images/44-5.png" /></a><br /><br />To exit nano, press &#39;Ctrl + X&#39;, then confirm with &#39;Y&#39;, and finally press &#39;ENTER&#39;.<br /><br />Now, we will apply the rule to search for additional files that share the same characteristics.<br /><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">sudo</span> yara -m -s -r starwars.yara ~<span style="color:#ff9d00;font-weight:700">/</span> 2&gt;<span style="color:#ff9d00;font-weight:700">/</span>dev<span style="color:#ff9d00;font-weight:700">/</span>null</pre></div><br /><br />&#39;-m&#39; feeds the YARA rule file, &#39;-s&#39; displays the strings YARA detected, and &#39;-r&#39; enables recursive searching.<br /><br />You will likely obtain matches for several files, specifically: kenobistrings.txt, kenobi.txt, kenobiIoC.yara, and lab.sh. We are already familiar with these files. However, there&#39;s a new addition: grievous.txt, located within the /home/Sitka/directory.<br /><a href=""><img src="images/44-6.png" alt="images/44-6.png" /></a><br /><br />By now, we have a solid grasp of the fundamental principles behind YARA and its applications. After gathering Indicators of Compromise (IoCs) for a potentially malicious file, we can leverage a YARA rule to perform a comprehensive system-wide scan. This scan aims to identify any other occurrences of these IoCs. This technique can be particularly valuable when you encounter intriguing references to files within strings or similar contexts.<br /><br /><h2> Yara Rule Generation with yarGen</h2><br /><br />Navigate to the specified file path and you will come across a file named &quot;deathstar.txt&quot;. To get there, run the following commands:<br /><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">cd</span> ~<span style="color:#ff9d00;font-weight:700">/</span>tools<span style="color:#ff9d00;font-weight:700">/</span>yarGen<span style="color:#ff9d00;font-weight:700">/</span>malwarez <span style="color:#ff9d00;font-weight:700">&amp;&amp;</span> <span style="color:#ff9d00;font-weight:700">ls</span></pre></div><br /><br /><a href=""><img src="images/44-7.png" alt="images/44-7.png" /></a><br /><br /><br /><br />This file, &quot;deathstar.txt,&quot; will be the one we employ to create another YARA rule. This time, we will be using the yarGen tool.<br /><br />Similarly to the previous file, in order to create a YARA rule, we need to gather its IoCs (Indicators of Compromise) first. To achieve this, we will use the ‘stat’ command to examine the file&#39;s properties.<br /><br /><a href=""><img src="images/44-8.png" alt="images/44-8.png" /></a><br /><br />IoC&#39;s:<br />• File name and type: deathstar.txt<br />• File path:  /home/Sitka/tools/yarGen/malwarez/deathstar.txt<br />• Size: 90 bytes<br /><br />Next, we will proceed to search for strings within that file <br /><br /><div class="codebox"><pre>strings deathstar.txt</pre></div><br /><a href=""><img src="images/44-9.png" alt="images/44-9.png" /></a><br /><br />IoC&#39;s:<br />• File name and type: deathstar.txt<br />• File path:  /home/Sitka/tools/yarGen/malwarez/deathstar.txt<br />• Size: 90 bytes<br />• Strings: VGhpcyBpcyBub3QgdGhlIGRyb2lkIHlvdSBhcmUgbG9va2luZyBmb3Iu O66. DV. LS. #%%%^storm##tropper<br /><br /><br />To further our investigation, we wil acquire the MD5, SHA-1, and SHA-256 hashes.<br /><br /><div class="codebox"><pre>md5sum deathstar.txt</pre></div><br /><div class="codebox"><pre>sha1sum deathstar.txt</pre></div><br /><div class="codebox"><pre>sha256sum deathstar.txt</pre></div><br /><a href=""><img src="images/44-10.png" alt="images/44-10.png" /></a><br /><br />IoC&#39;s:<br />• File name and type: deathstar.txt<br />• File path:  /home/Sitka/tools/yarGen/malwarez/deathstar.txt<br />• Size: 90 bytes<br />• Strings: VGhpcyBpcyBub3QgdGhlIGRyb2lkIHlvdSBhcmUgbG9va2luZyBmb3Iu O66. DV. LS. #%%%^storm##tropper<br />• MD5 Hash: 046d58458878c1cbafa660dfa497e86c<br /><br /><br /><br />To navigate into the yarGen folder, execute the following command:<br /><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">cd</span> .. <span style="color:#ff9d00;font-weight:700">&amp;&amp;</span> <span style="color:#ff9d00;font-weight:700">ls</span></pre></div><br /><br /><br />After that, run these commands:<br /><br /><div class="codebox"><pre>pip <span style="color:#ff9d00;font-weight:700">install</span> -r requirements.txt</pre></div><br /><br /><br />These commands will first move you up one directory level, then list the contents of that directory. Then, they will install the required packages specified in the &quot;requirements.txt&quot; file using pip. <br /><br /><a href=""><img src="images/44-11.png" alt="images/44-11.png" /></a><br /><br /><br /><br /><br /><h3>Run the following command to generate a YARA rule using yarGen:</h3><br /><div class="codebox"><pre>python yarGen.py -m .<span style="color:#ff9d00;font-weight:700">/</span>malwarez<span style="color:#ff9d00;font-weight:700">/</span> -o deathstarIoC.yara</pre></div><br /><br /><br />After executing this command, a file named &quot;deathstarIoC.yara&quot; will be created in your current directory. <br /><br /><a href=""><img src="images/44-12.png" alt="images/44-12.png" /></a><br /><br /><br />You can open this file using a text editor like nano or vim to examine the contents.<br /><div class="codebox"><pre>nano deathstarIoC.yara</pre></div><br /><br /><br /><a href=""><img src="images/44-13.png" alt="images/44-13.png" /></a><br /><br />yarGen was able to automatically generate this rule, significantly enhancing the process of constructing YARA rules. This automation not only accelerates rule creation but also improves their precision.<br /><br /><h3>Now, let&#39;s proceed to run this rule using YARA to confirm its functionality:</h3><br /><br /><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">sudo</span> yara -m -s -r starwarz.yara .<span style="color:#ff9d00;font-weight:700">/</span></pre></div><br /><br /><br />This command will use the YARA tool to scan for matches based on the &quot;deathstarIoC.yara&quot; rule within the current directory and its subdirectories. The -m flag specifies that the rule is to be used with metadata, the -s flag displays matching strings, and the -r flag enables recursive searching.<br /><br /><a href=""><img src="images/44-14.png" alt="images/44-14.png" /></a><br /><br /><br />This demonstration reveals that, utilizing the IoCs automatically gathered with yarGen, no other file possesses the same set of characteristics.<br /><br /><h2>Yara Rule Testing with Arya</h2><br /><br /><h3>Moving forward, we will craft a YARA rule using provided strings and hex code. Once the rule is complete, we will employ a tool named Arya to verify its accuracy.</h3><br /><br />Begin by executing the following command within the Arya folder located at ~/tools/arya:<br /><br /><div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">sudo</span> apt update <span style="color:#ff9d00;font-weight:700">&amp;&amp;</span> <span style="color:#ff9d00;font-weight:700">sudo</span> apt <span style="color:#ff9d00;font-weight:700">install</span> yara cmake <span style="color:#ff9d00;font-weight:700">&amp;&amp;</span> pip <span style="color:#ff9d00;font-weight:700">install</span> -r requirements.txt</pre></div><br /><br />Now that Arya is installed and ready for utilization, we can proceed to create the YARA rule:<br />Strings:<br />• yoda<br />• grievous<br />• kenobi<br />• deathstar<br /><br />Hex:<br />• 63 3a 5c 77 69 6e 64 6f 77 73 5c 73 79 73 74 65 6d 33 32 5c 62 6c 61 68 2e 65 78 65<br />• 62 6c 61 68 2e 64 6c 6c<br /><br />Other file attributes:<br />• 491 bytes<br />•uint16(0) == 0x5a4d<br /><br />To start, let&#39;s explain why each piece of information is important and how it can be useful for creating YARA rules.<br /><br />In the first part, we talk about &quot;Strings&quot;. These are groups of letters and symbols that make sense to people and appear within the file. In a YARA rule it would look like this <br /><br /><div class="codebox"><pre>rule strings<span style="color:#ff9d00;font-weight:700">{</span><br />			strings<span style="color:#ff9d00;font-weight:700">:</span><br />					<span style="color:#7f0044;font-weight:400">$s1</span><span style="color:#ff9d00;font-weight:700">:</span> “yoda”<br />					<span style="color:#7f0044;font-weight:400">$s2</span><span style="color:#ff9d00;font-weight:700">:</span> “grievous”<br />					<span style="color:#7f0044;font-weight:400">$s3</span><span style="color:#ff9d00;font-weight:700">:</span> “kenobi”<br />					<span style="color:#7f0044;font-weight:400">$s4</span><span style="color:#ff9d00;font-weight:700">:</span> “deathstar”<br />			condition<span style="color:#ff9d00;font-weight:700">:</span><br />					all of them	<br /><span style="color:#ff9d00;font-weight:700">}</span></pre></div><br />With the condition “all of them” this rule will search for a file with all of those strings in it. Of course we could use other conditions like “any of them” that would be like a “or” between them all.<br /><br /><br />The second part pertains to Hex code. This method is a way to represent computer data (binary form) using numerical values. Hex code is particularly useful for identifying specific patterns within files, such as their file type, especially when those files lack regular human-readable words. In this context, we&#39;re presented with two Hex codes. Let&#39;s delve into the information each one holds. For the first code, we&#39;ll exclusively employ the Linux command-line tool &quot;xxd&quot;. Meanwhile, for the second code, we&#39;ll utilize a tool called &quot;Cyberchef&quot;.<br /><br /><br />1:<br /><a href=""><img src="images/44-15.png" alt="images/44-15.png" /></a><br />2:<br /><a href=""><img src="images/44-16.png" alt="images/44-16.png" /></a><br /> In summary, the first Hex code contains a file path to an executable binary named “blah.exe” located at &quot;c:\windows\system32\blah.exe&quot;. The second Hex code signifies the name of another executable, “blah.dll”.<br /> <br /> We can translate this information for a YARA rule like this:<br /><div class="codebox"><pre> rule Hex<span style="color:#ff9d00;font-weight:700">{</span><br /> 		strings<span style="color:#ff9d00;font-weight:700">:</span><br /> 				<span style="color:#7f0044;font-weight:400">$exe_path</span><span style="color:#ff9d00;font-weight:700">:</span> <span style="color:#ff9d00;font-weight:700">{</span>63 3a 5c 77 69 6e 64 6f 77 73 5c 73 79 73 74 65 6d 33 32 5c 62 6c 61 68 2e 65 78 65<span style="color:#ff9d00;font-weight:700">}</span><br /> 				<span style="color:#7f0044;font-weight:400">$dll_name</span><span style="color:#ff9d00;font-weight:700">:</span> <span style="color:#ff9d00;font-weight:700">{</span>62 6c 61 68 2e 64 6c 6c<span style="color:#ff9d00;font-weight:700">}</span><br /> 		condition<span style="color:#ff9d00;font-weight:700">:</span><br /> 				any of them<br /> <span style="color:#ff9d00;font-weight:700">}</span></pre></div><br /><br />If we want to use boolean conditions to influence our search, YARA uses the same structure as typical boolean logic (and, or, not,...):<br /><div class="codebox"><pre> rule Hex<span style="color:#ff9d00;font-weight:700">{</span><br /> 		strings<span style="color:#ff9d00;font-weight:700">:</span><br /> 				<span style="color:#7f0044;font-weight:400">$exe_path</span><span style="color:#ff9d00;font-weight:700">:</span> <span style="color:#ff9d00;font-weight:700">{</span>63 3a 5c 77 69 6e 64 6f 77 73 5c 73 79 73 74 65 6d 33 32 5c 62 6c 61 68 2e 65 78 65<span style="color:#ff9d00;font-weight:700">}</span><br /> 				<span style="color:#7f0044;font-weight:400">$dll_name</span><span style="color:#ff9d00;font-weight:700">:</span> <span style="color:#ff9d00;font-weight:700">{</span>62 6c 61 68 2e 64 6c 6c<span style="color:#ff9d00;font-weight:700">}</span><br /> 		condition<span style="color:#ff9d00;font-weight:700">:</span><br /> 				<span style="color:#7f0044;font-weight:400">$exe_path</span> and <span style="color:#7f0044;font-weight:400">$dll_name</span><br /> <span style="color:#ff9d00;font-weight:700">}</span></pre></div><br />Also, we could use the strings &quot;c:\windows\system32\blah.exe&quot; and “blah.dll”, but we used the Hex code to spice things up.<br /><br />The third part we have two diferent atributes:<br />- Size, which is self explanatory <br />- Here we have an expression, lets break her into pieces. <br />   → First we have unit16(0), this is a function in YARA that it&#39;s used to read a 16-bit (2bytes) unsigned integer from a file at offset 0. Wait what? It&#39;s easy, The term &quot;offset 0&quot; refers to the position &quot;(0)&quot; of the file or in this case the start. And from there, he reads the first 16bits, or 2 bytes<br />   → in second we have 0x5a4d, this is a hexadecimal value that represents the magic number associated with the DOS MZ executable format. What is DOS MZ? DOS MZ is an executable file format used in MS-DOS (Operating system developed by Microsoft for personal computers in 1981), close to what PE are today (Portable Executables, EXE, DLL and other binary executable files).<br /> <br /> Now that we comprehend both sides of the expression, let&#39;s decipher the condition&#39;s significance and explore how we can harness it for our YARA rule. This condition will look like:<br /><div class="codebox"><pre>rule DOS_MZ <span style="color:#ff9d00;font-weight:700">{</span><br />		condition<span style="color:#ff9d00;font-weight:700">:</span><br /> 				unit16<span style="color:#ff9d00;font-weight:700">(</span>0<span style="color:#ff9d00;font-weight:700">)</span> == 0x5a4d<br /> <span style="color:#ff9d00;font-weight:700">}</span></pre></div>			<br /><br /><br /><h3>Now we will create a rule that will identify every file which contains any of the information gathered by the intelligence and then run Arya, with hopes that it will return that the rule has been ‘Triggered’.</h3><br /><br /><a href=""><img src="images/44-17.png" alt="images/44-17.png" /></a><br /><br />To confirm our rule works, we will execute Arya. To achieve this, we will use the following code:<br /><br /><div class="codebox"><pre>python3 ~<span style="color:#ff9d00;font-weight:700">/</span>tools<span style="color:#ff9d00;font-weight:700">/</span>arya<span style="color:#ff9d00;font-weight:700">/</span>src<span style="color:#ff9d00;font-weight:700">/</span>arya.py -i &lt;path to your rule&gt; -o youdidit.exe</pre></div><br /><br />This is exactly the reason we execute arya, this ARYA rule was outputing an error. If you pay attention to the description parameter inside “meta:”, you will see that i forgot to put &quot; at the start of the sentence. This is a great example on why we always should confirm that our code is alright.<br /><br />After running arya and fixing the problem we got this output.<br /><br /><a href=""><img src="images/44-18.png" alt="images/44-18.png" /></a><br /><br />Arya&#39;s output is designed to give you a summary of which rules were triggered by which files. This approach priotizes efficiency when dealing with numerous rules and files. However, the trade-off is that the output might not provide extensive details about specific content of the triggering files.<br /><br /> <div class="codebox"><pre><span style="color:#ff9d00;font-weight:700">sudo</span> yara -r everyInformation.yara ~<span style="color:#ff9d00;font-weight:700">/</span> 2&gt;<span style="color:#ff9d00;font-weight:700">/</span>dev<span style="color:#ff9d00;font-weight:700">/</span>null</pre></div><br /><br /><a href=""><img src="images/44-19.png" alt="images/44-19.png" /></a><br /><br /><br />Certainly, we have the option to investigate each occurrence and comprehend the details of these alerts. Moreover, we can delve into crafting more intricate rules involving loops and other advanced techniques. However, for the scope of this project, we have successfully achieved our objectives. We&#39;ve gained the knowledge and skills to:<br />• Identify fundamental file Indicators of Compromise (IoCs)<br />• Develop YARA rules from scratch<br />• Generate YARA rules efficiently using yarGen<br />• Validate and test YARA rules effectively using Arya<br /><br />In this project, we delved into the realm of threat detection using YARA rules. We learned to collect Indicators of Compromise (IoCs) from suspicious files, create YARA rules both manually and with the help of yarGen, and validate these rules using Arya. We gained practical insights into identifying potential threats and crafting rules that enhance our ability to detect them. This project equips us with essential skills in the realm of  threat mitigation.<br /><br /><br /><br /><br /><br /><br /></div>
</body>
</html>
